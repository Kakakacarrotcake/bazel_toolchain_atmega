#	PICC-18.INI
#	This file defines the memory sizes and organization
#	of a PIC18 device
#
#	Fields used are:
#
#	MAKE=<Name_of_manufacturer>
#			Identifies the manufacturer of this part.
#	ARCH=<processor_architecture>
#			PIC18 corresponds to the PIC18 architecture.
#	PROCID=<id>
#			Microchip processor identifier. This corresponds
#			to the processor field in Microchip COFF output.
#	ROMSIZE=<size_of_rom>
#			Size of program memory (bytes) in hex
#	RAMSIZE=<size_of_ram>
#			Size of data RAM (bytes) in hex
#	GPRBANKS=<range_start>-<range_end>,...
#			Specifies regions of banked memory used as GPRs, each range must be
#			be wholly located within a bank
#	SFRBANKS=<range_start>-<range_end>,...
#			Specifies regions of banked memory used for SFRs
#	COMMON=<range_start>-<range_end>
#			Specifies an area of GPRs that is mirrored in all banks.
#	SFRCOMMON=<range_start>-<range_end>
#			Specifies an area of SFRs that is mirrored in all banks.
#	ICD2RAM=<range_start>-<range_end>
#			Specifies an area of RAM that is used by
#			MPLAB-ICD2
#	ICD2ROM=<range_start>-<range_end>
#			Specifies an area of ROM that is used by
#			MPLAB-ICD2
#	CFGMEM=<range_start>-<range_end>
#			The region in memory in which the configuration bits are programmed.
#	USERIDMEM=<range_start>-<range_end>
#			The region in memory in which the user ids are programmed.
#	DEVIDMEM=<range_start>-<range_end>
#			The region in memory in which the device id is located.
#	REVIDMEM=<range_start>-<range_end>
#			The region in memory in which the revision id is located.
#	DIAMEM=<range_start>-<range_end>
#			The region in memory in which the Device Information Area (DIA) is located.
#	DCIMEM=<range_start>-<range_end>
#			The region in memory in which the Device Configuration Information (DCI) is located.
#	REALICE ranges apply to both the MPLAB REALICE and ICD3
#	They must include sufficient resources for both hardware and software
#   breakpoints where applicable
#	REALICEROM=<range_start>,<range_end>
#			Specifies an area of ROM that is used by
#			MPLAB-REALICE and MPLAB-ICD3
#	REALICERAM=<range_start>,<range_end>
#			Specifies an area of RAM that is used by
#			MPLAB-REALICE and MPLAB-ICD3
#	EXTMEM=<range_start>-<range-end>
#			Defines the address range of the external memory interface
#			for those chips which have one.
#	EEPROM=<range_start>,<range_end>
#			The addressable region of memory which contains EEPROM
#	FLASH_EW=<erase_size,write_size>
#			Defines the block erase size (bytes) of flash erase operations,
#			and the buffered write size (bytes) of flash write operations.
#	ERRATA=<bug1,bug2,bug3...>
#			List the default errata conditions to apply to this device
#			Handled errata types are:
#			4000 - Program mem accesses/jumps across 4000h address boundary
#			LFSR - Broken LFSR instruction
#			DAW - Broken DAW instruction
#			MINUS40 - Program memory reads at -40.C
#			EEPROMRD - Read EEDAT in immeadiate instruction after RD set
#			EEPROMADR - Don't set RD bit immediately after loading EEADR
#			EEPROMLVD - LVD must stabilise before writing EEPROM
#			FLASHLVD - LVD must stabilise before writing Flash
#			RESET - Needs NOP at Reset vector
#			FASTINTS - Fast interrupt shadow registers corruption
#			BSR15 - Flag problems when BSR holds value 15
#			TBLWTINT - clear interrupt registers before tblwt instruction
#			FW4000 - flash write exe must act on opposite side of 4000h boundary.
#			RESETRAM - RAM content can be corrupted during asynchronous reset
#			FETCH - Instruction fetches can be corrupted. FFFF after TBLRD, RETxx,
#				 at destination of GOTO/CALL instructions and at ISR vector addresses.
#	STACKDEPTH=<limit>
#			This is used set the maximum stack level depth for a processor. If not specified,
#			the default setting will be 31.
#	PLIB=[0|1]
#			Whether the peripheral library is supported for this device.
#   PCBITS=<number of bits>
#           How many implemented bits are there in the PC?
#   EEADRBITS=<number of bits)
#           How many bits are available to address EEPROM, if any.
#   BSTBITS=<number of bits>
#           How many bits are avalable in BSR for bank selection.
#	IVTBASE=<IVTBASEL address>,<IVTBASEL reset>,<IVTBASEH address>,<IVTBASEH reset>,<IVTBASEU address>,<IVTBASEU reset>
#			If the device has can have an interrupt vector table, this will describe the address and reset value of the
#			IVTBASE registers.  All values are in unqualified hexadecimal.
#	INTSTAT=<address>,<high-priority bit>,<low-priority bit>
#			If the device has can have an interrupt vector table, this will describe the location of the
#			INTCON1<INTSTAT> bits.  The first value is the address of the INTCON1 register in unqualified hexadecimal.
#			The remaining values are the positions of the bits that indicate which interrupt priority-levels are active.
#	INTSRC=<name>,<irq number>,<description>
#			If the device has can have an interrupt vector table, then each interrupt source will be described by one
#			of these fields.  The IRQ number is in decimal.
#	IVTENABLE=<config_setting>,<value>
#			If the device can have an interrupt vector table, then what is the configuration programming required
#			to enable it?
#	VOLSFRS=<range_start>-<range_end>,...
#			Instructions generated by the compiler that access SFRs in the given memory
#			ranges will won't be optimized by the assembly optimizer
#	SFR=<name>,<address>,<bit-width>
#			Describes a SFR of the device.  The address is in hexadecimal, and the bit-width decimal.
#			SFRs are sorted in order of address, and then by bit-width in descending order.  If an SFR duplicates
#			an address, then that SFR is an alias of the first with that address.  An SFR that has a bit-width
#			greater than the next, but the next also shares the same address, then that SFR is a joined SFR
#			of those that follow, but limited by its bit-width.
#	SFRFLD=<name>,<address>,<bit-position>,<bit-width>
#			Describes a SFR bit-fieldof the device.  The address is in hexadecimal, and the bit-width and
#			bit-position are decimal. SFRFLDs are sorted in order of address.
#	CFGPROG=<num_regs>,<delta>,<alignment>
#	USERIDPROG=<num_regs>,<delta>,<alignment>
#			These describe the programming characteristics of configuration and user id memory.
#			Where,
#			<num_regs> = the number of registers (equivalent to a CWORD in CFGDATA files) per programming unit.
#			<delta> = the address delta between contiguous registers, i.e. the addresses of a CWORD.
#			<alignment> = the address alignment of programming units, where the address is that of the first CWORD
#							in the programming unit.
#

[18FXXQ43]
ALIAS=18F57Q43
ARCH=PIC18XV
BSRBITS=0x6
CFGMEM=300000-300011
COMMON=500-55F
DCIMEM=3C0000-3C0009
DEVIDMEM=3FFFFE-3FFFFF
DIAMEM=2C0000-2C00FF
EEADRBITS=0x16
EEPROM=380000-3803FF
FAMILY=18fxxq43
FLASH_EW=80,1
GPRBANKS=560-5FF,600-6FF,700-7FF,800-8FF,900-9FF,A00-AFF,B00-BFF,C00-CFF,D00-DFF,E00-EFF,F00-FFF,1000-10FF,1100-11FF,1200-12FF,1300-13FF,1400-14FF,1500-15FF,1600-16FF,1700-17FF,1800-18FF,1900-19FF,1A00-1AFF,1B00-1BFF,1C00-1CFF,1D00-1DFF,1E00-1EFF,1F00-1FFF,2000-20FF,2100-21FF,2200-22FF,2300-23FF,2400-24FF,2500-25FF,2600-26FF,2700-27FF,2800-28FF,2900-29FF,2A00-2AFF,2B00-2BFF,2C00-2CFF,2D00-2DFF,2E00-2EFF,2F00-2FFF,3000-30FF,3100-31FF,3200-32FF,3300-33FF,3400-34FF,3500-35FF,3600-36FF,3700-37FF
INTSRC=SWINT,0,Software*Interrupt
INTSRC=HLVD,1,HLVD*Interrupt
INTSRC=OSF,2,Oscillator*Failure*Interrupt
INTSRC=CSW,3,Clock*Switch*Interrupt
INTSRC=CLC1,5,CLC1*Interrupt
INTSRC=IOC,7,Interrupt*on*change
INTSRC=INT0,8,External*Interrupt*0
INTSRC=ZCD,9,ZCD*Interrupt
INTSRC=AD,10,ADC*Interrupt
INTSRC=ACT,11,Active*Clock*Tuning*Interrupt
INTSRC=CMP1,12,Comparator*1*Interrupt
INTSRC=SMT1,13,SMT1*Interrupt
INTSRC=SMT1PRA,14,SMT1*Period*acqusition*Interrupt
INTSRC=SMT1PRW,15,SMT1*Pulse*width*acqusition*Interrupt
INTSRC=ADT,16,ADC*Treshold*Interrupt
INTSRC=DMA1SCNT,20,DMA1*Source*count*Interrupt
INTSRC=DMA1DCNT,21,DMA1*Destination*count*Interrupt
INTSRC=DMA1OR,22,DMA1*Overflow*Interrupt
INTSRC=DMA1A,23,DMA1*Abort*Interrupt
INTSRC=SPI1RX,24,SPI1*Receive*Interrupt
INTSRC=SPI1TX,25,SPI1*Transmit*Interrupt
INTSRC=SPI1,26,SPI1*Interrupt
INTSRC=TMR2,27,Timer2*Interrupt
INTSRC=TMR1,28,Timer1*Interrupt
INTSRC=TMR1G,29,Timer1*Gate*Interrupt
INTSRC=CCP1,30,CCP1*Interrupt
INTSRC=TMR0,31,Timer0*Interrupt
INTSRC=U1RX,32,UART1*Receive*Interrupt
INTSRC=U1TX,33,UART1*Transmit*Interrupt
INTSRC=U1E,34,UART1*Error*Interrupt
INTSRC=U1,35,UART1*Interrupt
INTSRC=PWM1PR,38,PWM1*Period*Interrupt
INTSRC=PWM1,39,PWM1*Interrupt
INTSRC=SPI2RX,40,SPI2*Receive*Interrupt
INTSRC=SPI2TX,41,SPI2*Transmit*Interrupt
INTSRC=SPI2,42,SPI2*Interrupt
INTSRC=TMR3,44,Timer3*Interrupt
INTSRC=TMR3G,45,Timer3*Gate*Interrupt
INTSRC=PWM2PR,46,PWM2*Period*Interrupt
INTSRC=PWM2,47,PWM2*Interrupt
INTSRC=INT1,48,External*Interrupt*1
INTSRC=CLC2,49,CLC2*Interrupt
INTSRC=CWG1,50,CWG1*Interrupt
INTSRC=NCO1,51,NCO1*Interrupt
INTSRC=DMA2SCNT,52,DMA2*Source*count*Interrupt
INTSRC=DMA2DCNT,53,DMA2*Destination*count*Interrupt
INTSRC=DMA2OR,54,DMA2*Overflow*Interrupt
INTSRC=DMA2A,55,DMA2*Abort*Interrupt
INTSRC=I2C1RX,56,I2C1*Receive*Interrupt
INTSRC=I2C1TX,57,I2C1*Transmit*Interrupt
INTSRC=I2C1,58,I2C1*Interrupt
INTSRC=I2C1E,59,I2C1*Error*Interrupt
INTSRC=CLC3,61,CLC3*Interrupt
INTSRC=PWM3PR,62,PWM3*Period*Interrupt
INTSRC=PWM3,63,PWM3*Interrupt
INTSRC=U2RX,64,UART2*Receive*Interrupt
INTSRC=U2TX,65,UART2*Transmit*Interrupt
INTSRC=U2E,66,UART2*Error*Interrupt
INTSRC=U2,67,UART2*Interrupt
INTSRC=TMR5,68,Timer5*Interrupt
INTSRC=TMR5G,69,Timer5*Gate*Interrupt
INTSRC=CCP2,70,CCP2*Interrupt
INTSRC=SCAN,71,Scanner*Interrupt
INTSRC=U3RX,72,UART3*Receive*Interrupt
INTSRC=U3TX,73,UART3*Transmit*Interrupt
INTSRC=U3E,74,UART3*Error*Interrupt
INTSRC=U3,75,UART3*Interrupt
INTSRC=CLC4,77,CLC4*Interrupt
INTSRC=INT2,80,External*Interrupt*2
INTSRC=CLC5,81,CLC5*Interrupt
INTSRC=CWG2,82,CWG2*Interrupt
INTSRC=NCO2,83,NCO2*Interrupt
INTSRC=DMA3SCNT,84,DMA3*Source*count*Interrupt
INTSRC=DMA3DCNT,85,DMA3*Destination*count*Interrupt
INTSRC=DMA3OR,86,DMA3*Overflow*Interrupt
INTSRC=DMA3A,87,DMA3*Abort*Interrupt
INTSRC=CCP3,88,CCP3*Interrupt
INTSRC=CLC6,89,CLC6*Interrupt
INTSRC=CWG3,90,CWG3*Interrupt
INTSRC=TMR4,91,Timer4*Interrupt
INTSRC=DMA4SCNT,92,DMA4*Source*count*Interrupt
INTSRC=DMA4DCNT,93,DMA4*Destination*count*Interrupt
INTSRC=DMA4OR,94,DMA4*Overflow*Interrupt
INTSRC=DMA4A,95,DMA4*Abort*Interrupt
INTSRC=U4RX,96,UART4*Receive*Interrupt
INTSRC=U4TX,97,UART4*Transmit*Interrupt
INTSRC=U4E,98,UART4*Error*Interrupt
INTSRC=U4,99,UART4*Interrupt
INTSRC=DMA5SCNT,100,DMA5*Source*count*Interrupt
INTSRC=DMA5DCNT,101,DMA5*Destination*count*Interrupt
INTSRC=DMA5OR,102,DMA5*Overflow*Interrupt
INTSRC=DMA5A,103,DMA5*Abort*Interrupt
INTSRC=U5RX,104,UART5*Receive*Interrupt
INTSRC=U5TX,105,UART5*Transmit*Interrupt
INTSRC=U5E,106,UART5*Error*Interrupt
INTSRC=U5,107,UART5*Interrupt
INTSRC=DMA6SCNT,108,DMA6*Source*count*Interrupt
INTSRC=DMA6DCNT,109,DMA6*Destination*count*Interrupt
INTSRC=DMA6OR,110,DMA6*Overflow*Interrupt
INTSRC=DMA6A,111,DMA6*Abort*Interrupt
INTSRC=CLC7,113,CLC7*Interrupt
INTSRC=CMP2,114,Comparator*2*Interrupt
INTSRC=NCO3,115,NCO3*Interrupt
INTSRC=NVM,120,NVM*Interrupt
INTSRC=CLC8,121,CLC8*Interrupt
INTSRC=CRC,122,CRC*Interrupt
INTSRC=TMR6,123,Timer6*Interrupt
INTSTAT=4D7,7,6
IVTBASE=45D,8,45E,0,45F,0
IVTENABLE=MVECEN,1
MAKE=TEST
PCBITS=0x15
PROCID=A2EC
RAMSIZE=3300
REVIDMEM=3FFFFC-3FFFFD
ROMSIZE=20000
SFRBANKS=000-0FF,100-1FF,200-2FF,300-3FF,400-45F,460-4FF
SFRCOMMON=460-4FF
STACKDEPTH=80
USERIDMEM=200000-2000FF
VOLSFRS=41-41,200-200
